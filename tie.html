<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Silk Tie - Rimmer's Collection</title>
  <link rel="icon" href="images/favicon-logo.svg" type="image/svg+xml">
  <link rel="stylesheet" href="css/style.css?v=20250926-7">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script>
    // Tag <html> with .is-ios for iOS (including iPadOS desktop mode) to allow iOS-only CSS
    (function(){
      try {
        var ua = navigator.userAgent || '';
        var iPadOSDesktop = (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        var isiOS = /iPad|iPhone|iPod/.test(ua) || iPadOSDesktop;
        if (isiOS) { document.documentElement.classList.add('is-ios'); }
      } catch(e) {}
    })();
  </script>
  </head>
<body class="tie-page tie-page-body">
  <a href="#main" class="skip-link">Skip to content</a>
  <!-- Thin preheader bar: always visible, header offsets below it -->
  <div class="preheader preheader--visible" id="preheader" aria-hidden="false">
    <div class="preheader__inner">
  <span class="preheader__text">Italian Artisanship in Every Stitch</span>
  <div class="preheader__lang">
    <div class="lang-switcher">
      <button class="lang-toggle" type="button" aria-label="Language" aria-expanded="false" aria-controls="lang-menu">
        <span class="label">English</span>
        <span class="arrow" aria-hidden="true"></span>
      </button>
      <div id="lang-menu" class="lang-menu" role="menu" aria-label="Language options">
        <button class="lang-option" role="menuitemradio" aria-checked="true" data-lang="en">English</button>
        <button class="lang-option" role="menuitemradio" aria-checked="false" data-lang="he">עברית</button>
      </div>
    </div>
  </div>
    </div>
  </div>

  <header class="shrunk" id="site-header" role="banner">
    <div class="header-flex">
      <div class="header-left">
        <a href="contact.html" class="contact-link" style="color: var(--brand-blue); text-decoration: underline; font-weight: bold; font-size: 1.1em; margin-right: 8px; background: none; border: none; padding: 0; border-radius: 0;">Contact</a>
      </div>
      <div class="header-center">
        <a href="index.html"><img src="images/logo.svg" alt="Rimmer's Logo" class="logo"></a>
      </div>
      <div class="header-right">
        <button class="menu-toggle" aria-label="Open menu" aria-expanded="false" aria-controls="mobile-menu">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </button>
      </div>
    </div>
    <nav id="mobile-menu" class="mobile-menu" role="navigation" aria-label="Main menu">
      <a href="index.html">Home</a>
      <a href="contact.html">Contact</a>
    </nav>
  </header>

  <script>
    // Mobile hamburger toggle for tie pages
    (function() {
      var toggle = document.querySelector('.menu-toggle');
      var menu = document.getElementById('mobile-menu');
      if (!toggle || !menu) return;

      function closeMenu() {
        menu.classList.remove('open');
        toggle.classList.remove('open');
        toggle.setAttribute('aria-expanded', 'false');
        try { toggle.blur(); } catch (e) {}
      }
      function openMenu() {
        menu.classList.add('open');
        toggle.classList.add('open');
        toggle.setAttribute('aria-expanded', 'true');
      }
      function toggleMenu() {
        if (menu.classList.contains('open')) closeMenu(); else openMenu();
      }
      toggle.addEventListener('click', function(e) {
        e.stopPropagation();
        toggleMenu();
      });
      document.addEventListener('click', function(e) {
        if (!menu.contains(e.target) && !toggle.contains(e.target)) {
          closeMenu();
        }
      });
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') closeMenu();
      });
    })();

    // Always-visible preheader: set CSS var so sticky header sits below it
    (function(){
      var pre = document.getElementById('preheader');
      if(!pre) return;
      function setOffset(){
        try {
          var h = pre.getBoundingClientRect().height || 0;
          document.documentElement.style.setProperty('--preheader-height', h + 'px');
          pre.setAttribute('aria-hidden','false');
        } catch(e) {}
      }
      window.addEventListener('load', setOffset, {passive:true});
      window.addEventListener('resize', setOffset, {passive:true});
      setOffset();
    })();

    // Language dropdown behavior (same as index)
    (function(){
      var toggle = document.querySelector('.lang-toggle');
      var menu = document.getElementById('lang-menu');
      if (!toggle || !menu) return;
      function setLang(lang){
        var html = document.documentElement;
        if (lang === 'he') {
          html.setAttribute('lang', 'he');
          html.setAttribute('dir', 'rtl');
          toggle.querySelector('.label').textContent = 'עברית';
          menu.querySelectorAll('.lang-option').forEach(function(opt){ opt.setAttribute('aria-checked', opt.dataset.lang === 'he' ? 'true' : 'false'); });
        } else {
          html.setAttribute('lang', 'en');
          html.setAttribute('dir', 'ltr');
          toggle.querySelector('.label').textContent = 'English';
          menu.querySelectorAll('.lang-option').forEach(function(opt){ opt.setAttribute('aria-checked', opt.dataset.lang === 'en' ? 'true' : 'false'); });
        }
        try { localStorage.setItem('siteLang', lang); } catch(e){}
      }
      function openMenu(){ menu.classList.add('open'); toggle.setAttribute('aria-expanded', 'true'); }
      function closeMenu(){ menu.classList.remove('open'); toggle.setAttribute('aria-expanded', 'false'); }
      toggle.addEventListener('click', function(e){ e.stopPropagation(); if (menu.classList.contains('open')) closeMenu(); else openMenu(); });
      document.addEventListener('click', function(e){ if (!menu.contains(e.target) && !toggle.contains(e.target)) closeMenu(); });
      document.addEventListener('keydown', function(e){ if (e.key === 'Escape') closeMenu(); });
      menu.addEventListener('click', function(e){ var btn = e.target.closest('.lang-option'); if (!btn) return; setLang(btn.dataset.lang); closeMenu(); });
      try { var saved = localStorage.getItem('siteLang'); if (saved === 'he' || saved === 'en') setLang(saved); } catch(e){}
    })();

    // Align preheader to the tie carousel image edges on desktop
    (function(){
      function alignPreheaderToCarousel(){
        var desktop = window.matchMedia('(min-width: 1200px)').matches;
        var root = document.documentElement;
        if (!desktop) { root.style.removeProperty('--preheader-inner-left'); root.style.removeProperty('--preheader-inner-width'); return; }
        // Try using the exact distances saved by the index page for consistency across the site
        try {
          var saved = localStorage.getItem('preheaderAlign');
          if (saved) {
            var obj = JSON.parse(saved);
            if (obj && typeof obj.left === 'number' && typeof obj.width === 'number') {
              root.style.setProperty('--preheader-inner-left', obj.left + 'px');
              root.style.setProperty('--preheader-inner-width', obj.width + 'px');
              return;
            }
          }
        } catch(e){}
        // Fallback: align to first carousel image edges
        var firstImg = document.querySelector('.tie-carousel .carousel-slide img');
        if (!firstImg) return;
        var r = firstImg.getBoundingClientRect();
        var leftDoc = Math.round(window.scrollX + r.left);
        var rightDoc = Math.round(window.scrollX + r.right);
        var containerLeft = leftDoc;
        var containerWidth = Math.max(0, rightDoc - leftDoc);
        root.style.setProperty('--preheader-inner-left', containerLeft + 'px');
        root.style.setProperty('--preheader-inner-width', containerWidth + 'px');
      }
      var tid; window.addEventListener('resize', function(){ clearTimeout(tid); tid = setTimeout(alignPreheaderToCarousel, 120); }, {passive:true});
      window.addEventListener('load', alignPreheaderToCarousel);
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(alignPreheaderToCarousel, 300); });
      // Expose so we can call after images render
      window.__alignPreheaderToCarousel = alignPreheaderToCarousel;
    })();
  </script>

  <main id="main">
  <h1 class="sr-only">Tie details</h1>
  <div class="tie-details">
    <div class="tie-carousel" role="region" aria-roledescription="carousel" aria-label="Tie image gallery">
      <div class="carousel-container">
        <div class="carousel-track" id="carousel-track">
          <!-- Slides injected by JS -->
        </div>
        <!-- Desktop-only navigation arrows (hidden on mobile/tablet via CSS) -->
        <button class="carousel-nav prev" type="button" aria-label="Previous image" title="Previous">
          <i class="fas fa-chevron-left" aria-hidden="true"></i>
        </button>
        <button class="carousel-nav next" type="button" aria-label="Next image" title="Next">
          <i class="fas fa-chevron-right" aria-hidden="true"></i>
        </button>
  <div id="carousel-numeric" class="carousel-numeric" aria-live="polite" aria-atomic="true">1/1</div>
      </div>
      <p id="carousel-status" class="sr-only" aria-live="polite"></p>
    </div>

    <!-- Info block below the images: brand label (via CSS), title, and price -->
    <div class="tie-info">
      <div class="tie-header">
        <h2 id="tie-title"><span class="title-text">Loading...</span></h2>
        <div id="tie-price" class="tie-price">₪350,00</div>
      </div>
      
      <!-- Contact Us Button -->
      <div class="tie-contact-section">
        <button type="button" class="tie-contact-btn" id="contact-trigger">Contact us</button>
      </div>
    </div>

    <p class="back-actions">
      <a href="index.html" class="back-link-inline">← Back to Collection</a>
    </p>
  </div>
  </main>

  <!-- Contact Curtain Modal -->
  <div id="contact-overlay" class="contact-overlay">
    <div class="contact-curtain" id="contact-curtain">
      <button type="button" class="contact-close" id="contact-close" aria-label="Close contact panel">
        <i class="fas fa-times"></i>
      </button>
      
      <div class="contact-content">
        <h2>Contact us</h2>
        
        <p class="contact-message">We'll be delighted to assist you with any questions or requests</p>
        
        <div class="contact-options">
          <a href="mailto:shop.rimmers@gmail.com" class="contact-option">
            <i class="fas fa-envelope"></i>
            <span>shop.rimmers@gmail.com</span>
          </a>
          
          <a href="https://wa.me/972535455468" target="_blank" rel="noopener" class="contact-option">
            <i class="fab fa-whatsapp"></i>
            <span>WhatsApp</span>
          </a>
          
          <a href="tel:+972535455468" class="contact-option">
            <i class="fas fa-phone"></i>
            <span>+972 53-545-5468</span>
          </a>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Tiny data-driven tie page: reads ?id=NUMBER and loads images/title from data/ties.json
    const params = new URLSearchParams(location.search);
    const id = params.get('id');

    function renderTie(tie) {
      const titleEl = document.getElementById('tie-title');
      const priceEl = document.getElementById('tie-price');
      const track = document.getElementById('carousel-track');
      const numeric = document.getElementById('carousel-numeric');
      // Title and price
      if (titleEl) {
        const span = titleEl.querySelector('.title-text');
        if (span) span.textContent = tie.title; else titleEl.textContent = tie.title;
      }
      if (priceEl) {
        const raw = (tie.price || '₪350,00').toString().trim();
        const hasSymbol = raw.startsWith('₪');
        const amount = hasSymbol ? raw.slice(1) : raw;
        priceEl.innerHTML = `${hasSymbol ? '<span class="currency" aria-hidden="true">₪</span>' : ''}<span class="amount">${amount}</span>`;
        if (hasSymbol) {
          try { priceEl.setAttribute('aria-label', `NIS ${amount}`); } catch(e) {}
        }
      }

      // Slides
      track.innerHTML = '';
  // Sold-out badges are index-only per requirement; ignore on tie pages
  const isSoldOutTie = false;

      tie.images.forEach((img, idx) => {
        const slide = document.createElement('div');
        slide.className = 'carousel-slide';
          slide.setAttribute('role', 'group');
          slide.setAttribute('aria-roledescription', 'slide');
          slide.setAttribute('aria-label', `Image ${idx + 1} of ${tie.images.length}`);
          if (idx !== 0) slide.setAttribute('aria-hidden', 'true');
  const image = document.createElement('img');
  image.src = img.src;
  image.loading = (idx === 0 ? 'eager' : 'lazy');
  image.decoding = 'async';
    image.alt = img.alt || tie.title + ' - Image ' + (idx + 1);
    slide.appendChild(image);
        // If this tie is sold out, add a decorative badge to each slide
        // No sold-out badges on tie pages
        track.appendChild(slide);
      });
      // Reset carousel state
      currentSlideIndex = 0;
      slides = document.querySelectorAll('.carousel-slide');
      if (numeric) {
        numeric.textContent = `1/${slides.length || 1}`;
      }
      updateCarousel();
      try { if (window.__alignPreheaderToCarousel) { setTimeout(window.__alignPreheaderToCarousel, 50); } } catch(e){}
    }

    (function(){
  var ver = (window.__TIES_VER__ || '20250925-3');
      return fetch('data/ties.json?v=' + encodeURIComponent(ver), { cache: 'no-store' });
    })()
      .then(r => r.json())
      .then(data => {
        const tie = data.ties[id];
        if (!tie) throw new Error('Tie not found: ' + id);
        renderTie(tie);
        try { document.title = tie.title + " | Rimmer's"; } catch(e) {}
      })
      .catch(err => {
        document.getElementById('tie-title').textContent = 'Tie not found';
        console.error(err);
      });

    // Carousel logic (robust iOS-friendly with pointer events + live dragging)
    let currentSlideIndex = 0;
    let slides = [];
    const track = document.getElementById('carousel-track');
    const statusEl = document.getElementById('carousel-status');
    const numericEl = document.getElementById('carousel-numeric');
    let isAnimating = false;
    // Detect iOS Safari specifically (exclude Chrome/Firefox/Edge on iOS)
    function isIOSSafari(){
      var ua = navigator.userAgent || '';
      var iPadOSDesktop = (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      var isiOS = /iPad|iPhone|iPod/.test(ua) || iPadOSDesktop;
      var nonSafari = /CriOS|FxiOS|EdgiOS/.test(ua);
      return !!(isiOS && !nonSafari);
    }

    function getContainerWidth() {
      const container = track.parentElement || track;
      return (container && container.clientWidth) ? container.clientWidth : 1;
    }

    function setTransformByIndex(index) {
      const w = getContainerWidth();
      const px = -(index * w);
      track.style.transform = `translate3d(${px}px, 0, 0)`;
    }

    function updateA11y(index) {
      if (slides[index]) {
        slides.forEach((s, idx) => s.setAttribute('aria-hidden', idx === index ? 'false' : 'true'));
      }
      const total = slides.length || 1;
      const pos = index + 1;
      if (statusEl) statusEl.textContent = `Image ${pos} of ${total}`;
      if (numericEl) numericEl.textContent = `${pos}/${total}`;
    }

    function updateCarousel() {
      setTransformByIndex(currentSlideIndex);
      updateA11y(currentSlideIndex);
      // Extra safety: clear any stuck animation state after a frame
      if (isAnimating) {
        setTimeout(function(){ isAnimating = false; }, 0);
      }
    }

    function gotoSlide(index) {
      if (isAnimating) return;
      const total = slides.length;
      if (!total) return;
      // wrap-around
      if (index >= total) index = 0;
      if (index < 0) index = total - 1;
      isAnimating = true;
      track.style.transition = 'transform 300ms ease';
      currentSlideIndex = index;
      setTransformByIndex(currentSlideIndex);
      // On iOS Safari, set a safety timer in case transitionend doesn't fire
  // Always set a safety timer in case transitionend doesn't fire reliably (seen on iOS and occasionally elsewhere)
  scheduleUnlockFallback();
    }

    // Ensure animations always unlock on iOS Safari (transitionend can be flaky)
    let unlockTimer = null;
    function clearUnlockTimer(){ if(unlockTimer){ clearTimeout(unlockTimer); unlockTimer=null; } }
  function scheduleUnlockFallback(){ clearUnlockTimer(); unlockTimer = setTimeout(function(){ isAnimating=false; updateA11y(currentSlideIndex); setTransformByIndex(currentSlideIndex); }, 500); }
    track.addEventListener('transitionend', function(ev) {
      // Some engines may report vendor-specific names; accept any property containing 'transform'
      if (ev && ev.propertyName && ev.propertyName.indexOf('transform') === -1) return;
      isAnimating = false; clearUnlockTimer();
      // ensure a11y state sync after animation
      updateA11y(currentSlideIndex);
    });
    track.addEventListener('webkitTransitionEnd', function(ev){
      if (ev && ev.propertyName && ev.propertyName.indexOf('transform') === -1) return;
      isAnimating = false; clearUnlockTimer();
      updateA11y(currentSlideIndex);
    });

    function changeSlide(direction) {
      gotoSlide(currentSlideIndex + direction);
    }

    function currentSlide(index) {
      gotoSlide(index - 1);
    }

    // Pointer Events with touch fallback for reliable swiping on iOS/Chrome
    let pointerId = null;
    let startX = 0;
    let deltaX = 0;
    let dragging = false;
  const SWIPE_THRESHOLD = 0.16; // slightly easier to advance on iOS
    const EDGE_RESISTANCE = 0.35; // resistance factor near edges

    function onPointerDown(e) {
      // If we ever got stuck, allow a new drag to reset state
      if (isAnimating) { isAnimating = false; clearUnlockTimer(); track.style.transition = 'none'; }
      dragging = true;
      deltaX = 0;
      pointerId = e.pointerId;
      startX = e.clientX;
      track.style.transition = 'none';
      track.setPointerCapture && track.setPointerCapture(pointerId);
      track.style.willChange = 'transform';
    }

    function onPointerMove(e) {
      if (!dragging) return;
      const x = e.clientX;
      deltaX = x - startX;
      const w = getContainerWidth();
      let dx = deltaX; // positive when dragging right
      // Apply resistance at edges
      if ((currentSlideIndex === 0 && dx > 0) || (currentSlideIndex === slides.length - 1 && dx < 0)) {
        dx *= EDGE_RESISTANCE;
      }
  const base = -(currentSlideIndex * w);
  track.style.transform = `translate3d(${base + dx}px, 0, 0)`;
    }

    function onPointerUpOrCancel() {
      if (!dragging) return;
      dragging = false;
      track.style.willChange = 'auto';
      const w = getContainerWidth();
      const traveled = Math.abs(deltaX) / w;
      track.style.transition = 'transform 300ms ease';
      if (traveled > SWIPE_THRESHOLD) {
        const dir = deltaX < 0 ? 1 : -1; // left drag moves to next (dir=1)
        gotoSlide(currentSlideIndex + dir);
      } else {
  // snap back and ensure transform matches index
  setTransformByIndex(currentSlideIndex);
      }
      pointerId = null;
      deltaX = 0;
    }

    // Detect any iOS device (Safari or Chrome on iOS) to force touch fallback
    function isIOSDevice() {
      var ua = navigator.userAgent || '';
      var iOS = /iPad|iPhone|iPod/.test(ua);
      var iPadOSDesktopMode = (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      return !!(iOS || iPadOSDesktopMode);
    }

    // Only enable swipe on non-desktop screens; desktop uses arrows only
    const isDesktop = window.matchMedia && window.matchMedia('(min-width: 1024px)').matches;
    // Attach Pointer Events if available and NOT on iOS and NOT desktop; otherwise use touch fallback
    if (!isDesktop && window.PointerEvent && !isIOSDevice()) {
      track.addEventListener('pointerdown', onPointerDown);
      track.addEventListener('pointermove', onPointerMove);
      track.addEventListener('pointerup', onPointerUpOrCancel);
      track.addEventListener('pointercancel', onPointerUpOrCancel);
    } else if (!isDesktop) {
      // Fallback to touch events with non-passive move
      let touchStartX = 0;
      let lastX = 0;
      let locked = false;
      const LOCK_THRESHOLD = 8; // px to lock horizontal
      track.addEventListener('touchstart', (e) => {
        // If we ever got stuck, allow a new drag to reset state
        if (isAnimating) { isAnimating = false; clearUnlockTimer(); track.style.transition = 'none'; }
        const t = e.touches[0];
        touchStartX = t.clientX;
        lastX = touchStartX;
        dragging = true;
        locked = false;
        track.style.transition = 'none';
        track.style.willChange = 'transform';
      }, { passive: false });
      track.addEventListener('touchmove', (e) => {
        if (!dragging) return;
        const t = e.touches[0];
        const x = t.clientX;
        const dx = x - touchStartX;
        lastX = x;
        if (!locked && Math.abs(dx) > LOCK_THRESHOLD && e.cancelable) {
          // prevent page scroll once horizontal intent is clear
          e.preventDefault();
          locked = true;
        }
        const w = getContainerWidth();
        let dragX = dx;
        if ((currentSlideIndex === 0 && dragX > 0) || (currentSlideIndex === slides.length - 1 && dragX < 0)) {
          dragX *= EDGE_RESISTANCE;
        }
  const base = -(currentSlideIndex * w);
  track.style.transform = `translate3d(${base + dragX}px, 0, 0)`;
      }, { passive: false });
      track.addEventListener('touchend', (e) => {
        if (!dragging) return;
        dragging = false;
        track.style.willChange = 'auto';
        const endX = (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : lastX);
        const w = getContainerWidth();
        const traveled = Math.abs(endX - touchStartX) / w;
        track.style.transition = 'transform 300ms ease';
        if (traveled > 0.18) {
          const dir = (endX - touchStartX) < 0 ? 1 : -1;
          gotoSlide(currentSlideIndex + dir);
        } else {
          setTransformByIndex(currentSlideIndex);
        }
      }, { passive: true });
      track.addEventListener('touchcancel', () => {
        dragging = false;
        track.style.willChange = 'auto';
        track.style.transition = 'transform 300ms ease';
        setTransformByIndex(currentSlideIndex);
      }, { passive: true });
    }

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') changeSlide(-1);
      else if (e.key === 'ArrowRight') changeSlide(1);
    });

    // Click navigation (desktop arrows)
    (function(){
      var prevBtn = document.querySelector('.carousel-nav.prev');
      var nextBtn = document.querySelector('.carousel-nav.next');
      if (prevBtn) prevBtn.addEventListener('click', function(){ changeSlide(-1); });
      if (nextBtn) nextBtn.addEventListener('click', function(){ changeSlide(1); });
    })();

    // Re-sync transform after resize/orientation changes (pixel-based transforms)
    function debounce(fn, delay){ let t; return function(){ const ctx=this, args=arguments; clearTimeout(t); t=setTimeout(function(){ fn.apply(ctx,args); }, delay); } }
    function syncTransformToSize(){ const prev=track.style.transition; track.style.transition='none'; setTransformByIndex(currentSlideIndex); void track.offsetWidth; track.style.transition=prev; }
    window.addEventListener('resize', debounce(syncTransformToSize, 120));
    window.addEventListener('orientationchange', debounce(syncTransformToSize, 120));

    // Contact Curtain functionality
    (function() {
      const contactTrigger = document.getElementById('contact-trigger');
      const contactOverlay = document.getElementById('contact-overlay');
      const contactClose = document.getElementById('contact-close');
      
      if (!contactTrigger || !contactOverlay || !contactClose) return;
      
      function openContactCurtain() {
        contactOverlay.classList.add('active');
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
      }
      
      function closeContactCurtain() {
        contactOverlay.classList.remove('active');
        document.body.style.overflow = ''; // Restore scrolling
      }
      
      // Open curtain when clicking contact button
      contactTrigger.addEventListener('click', function(e) {
        e.preventDefault();
        openContactCurtain();
      });
      
      // Close curtain when clicking X button
      contactClose.addEventListener('click', function(e) {
        e.preventDefault();
        closeContactCurtain();
      });
      
      // Close curtain when clicking overlay background (not the curtain itself)
      contactOverlay.addEventListener('click', function(e) {
        if (e.target === contactOverlay) {
          closeContactCurtain();
        }
      });
      
      // Close curtain with Escape key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && contactOverlay.classList.contains('active')) {
          closeContactCurtain();
        }
      });
    })();
  </script>
  <footer class="site-footer" role="contentinfo" aria-label="Site footer">
    <div class="footer-main">
      <div class="footer-left">
        <a href="index.html" class="footer-logo" aria-label="Rimmer's Home">
          <img src="images/logo.svg" alt="Rimmer's Logo" />
        </a>
        <div class="footer-contact" aria-label="Contact information">
          <a class="footer-phone" href="tel:+972533191655" aria-label="Call us at plus nine seven two five three three one nine one six five five">Contact Us +972 53 319 1655</a>
          <a class="footer-email" href="mailto:shop.rimmers@gmail.com" aria-label="Email shop dot rimmers at gmail dot com">Email: shop.rimmers@gmail.com</a>
          <a class="footer-accessibility" href="accessibility.html">Accessibility</a>
        </div>
      </div>
    </div>
  <div class="footer-credit"><div class="footer-credit-inner"><p>© 2025 Rimmers.</p></div></div>
  </footer>

  
</body>
</html>
